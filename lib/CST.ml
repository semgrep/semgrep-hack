(* Generated by ocaml-tree-sitter. *)
(*
   hack grammar

   entrypoint: script
*)

open! Sexplib.Conv
open Tree_sitter_run

type heredoc_end = Token.t

type pat_466b599 = Token.t (* pattern function\s*\( *)

type false_ = [
    `False_68934a3 of Token.t (* "false" *)
  | `False_f8320b2 of Token.t (* "False" *)
  | `FALSE of Token.t (* "FALSE" *)
]

type pat_b6fe07e = Token.t (* pattern <\?[hH][hH] *)

type xhp_identifier =
  Token.t (* pattern [a-zA-Z_][a-zA-Z0-9_]*([-:][a-zA-Z0-9_]+)* *)

type string_ = Token.t

type type_modifier = [
    `AT of Token.t (* "@" *)
  | `QMARK of Token.t (* "?" *)
  | `TILDE of Token.t (* "~" *)
]

type float_ = Token.t

type integer = Token.t

type heredoc_start_newline = Token.t

type scope_identifier = [
    `Self of Token.t (* "self" *)
  | `Parent of Token.t (* "parent" *)
  | `Static of Token.t (* "static" *)
]

type use_type = [
    `Name of Token.t (* "namespace" *)
  | `Func of Token.t (* "function" *)
  | `Type of Token.t (* "type" *)
  | `Const of Token.t (* "const" *)
]

type xhp_category_identifier =
  Token.t (* pattern %[a-zA-Z_][a-zA-Z0-9_]*([-:][a-zA-Z0-9_]+)* *)

type true_ = [
    `True_b326b50 of Token.t (* "true" *)
  | `True_f827cf4 of Token.t (* "True" *)
  | `TRUE of Token.t (* "TRUE" *)
]

type heredoc_end_newline = Token.t

type heredoc_body = Token.t

type semgrep_identifier = Token.t (* pattern \$[A-Z_][A-Z_0-9]* *)

type xhp_comment = Token.t

type visibility_modifier = [
    `Public of Token.t (* "public" *)
  | `Prot of Token.t (* "protected" *)
  | `Priv of Token.t (* "private" *)
]

type variable = Token.t

type tok_pdyn_p1_as = Token.t

type identifier =
  Token.t (* pattern [a-zA-Z_\x80-\xff][a-zA-Z0-9_\x80-\xff]* *)

type xhp_class_identifier =
  Token.t (* pattern :[a-zA-Z_][a-zA-Z0-9_]*([-:][a-zA-Z0-9_]+)* *)

type tok_pdyn_n1_as = Token.t

type xhp_string = Token.t

type semgrep_variadic_identifier =
  Token.t (* pattern \$\.\.\.[A-Z_][A-Z_0-9]* *)

type collection_type = [
    `Array of Token.t (* "array" *)
  | `Varray of Token.t (* "varray" *)
  | `Darray of Token.t (* "darray" *)
  | `Vec of Token.t (* "vec" *)
  | `Dict of Token.t (* "dict" *)
  | `Keyset of Token.t (* "keyset" *)
]

type tok_lcurldollar_pat_0e8e4b6 = Token.t

type null = [
    `Null_37a6259 of Token.t (* "null" *)
  | `Null_bbb93ef of Token.t (* "Null" *)
  | `NULL of Token.t (* "NULL" *)
]

type anon_choice_QMARKDASHGT_ce9cc19 = [
    `QMARKDASHGT of Token.t (* "?->" *)
  | `DASHGT of Token.t (* "->" *)
]

type heredoc_start = Token.t

type empty_statement = [
    `SEMI of Token.t (* ";" *)
  | `Ellips of Token.t (* "..." *)
]

type anon_choice_str_d42aa42 = [
    `Str of string_ (*tok*)
  | `Int of integer (*tok*)
]

type xhp_category_declaration = (
    Token.t (* "category" *)
  * xhp_category_identifier (*tok*)
  * (Token.t (* "," *) * xhp_category_identifier (*tok*))
      list (* zero or more *)
  * Token.t (* ";" *)
)

type trait_alias_clause = (
    identifier (*tok*)
  * Token.t (* "as" *)
  * [
        `Visi_modi_opt_id of (visibility_modifier * identifier (*tok*) option)
      | `Opt_visi_modi_id of (
            visibility_modifier option
          * identifier (*tok*)
        )
    ]
)

type prefixed_string = (identifier (*tok*) * string_ (*tok*))

type semgrep_extended_identifier = [
    `Semg_id of semgrep_identifier (*tok*)
  | `Id of identifier (*tok*)
]

type qualified_identifier = [
    `Choice_opt_id_rep1_back_id of [
        `Opt_id_rep1_back_id of (
            identifier (*tok*) option
          * (Token.t (* "\\" *) * identifier (*tok*)) list (* one or more *)
        )
      | `Id of identifier (*tok*)
    ]
  | `Semg_id of semgrep_identifier (*tok*)
]

type xhp_identifier_ = [
    `Xhp_id of xhp_identifier (*tok*)
  | `Xhp_class_id of xhp_class_identifier (*tok*)
]

type xhp_attribute_expression = [
    `Xhp_id of xhp_identifier (*tok*)
  | `Xhp_class_id of xhp_class_identifier (*tok*)
  | `Xhp_cate_id of xhp_category_identifier (*tok*)
  | `Xhp_bin_exp of (
        xhp_attribute_expression * Token.t (* "|" *)
      * xhp_attribute_expression
    )
  | `Xhp_post_un_exp of (
        xhp_attribute_expression
      * [
            `PLUS of Token.t (* "+" *)
          | `STAR of Token.t (* "*" *)
          | `QMARK of Token.t (* "?" *)
        ]
    )
  | `Xhp_paren_exp of (
        Token.t (* "(" *)
      * xhp_attribute_expression
      * (Token.t (* "," *) * xhp_attribute_expression)
          list (* zero or more *)
      * Token.t (* ")" *)
    )
]

type class_modifier = [
    `Abst_modi of Token.t (* "abstract" *)
  | `Final_modi of Token.t (* "final" *)
]

type member_modifier = [
    `Visi_modi of visibility_modifier
  | `Static_modi of Token.t (* "static" *)
  | `Abst_modi of Token.t (* "abstract" *)
  | `Final_modi of Token.t (* "final" *)
]

type literal = [
    `Str of string_ (*tok*)
  | `Int of integer (*tok*)
  | `Float of float_ (*tok*)
  | `True of true_
  | `False of false_
  | `Null of null
]

type primitive_type = [
    `Bool of Token.t (* "bool" *)
  | `Float of Token.t (* "float" *)
  | `Int of Token.t (* "int" *)
  | `Str of Token.t (* "string" *)
  | `Arra of Token.t (* "arraykey" *)
  | `Void of Token.t (* "void" *)
  | `Nonn of Token.t (* "nonnull" *)
  | `Null of null
  | `Mixed of Token.t (* "mixed" *)
  | `Dyna of Token.t (* "dynamic" *)
  | `Nore of Token.t (* "noreturn" *)
]

type xhp_enum_type = (
    Token.t (* "enum" *)
  * Token.t (* "{" *)
  * anon_choice_str_d42aa42
  * (Token.t (* "," *) * anon_choice_str_d42aa42) list (* zero or more *)
  * Token.t (* "," *) option
  * Token.t (* "}" *)
)

type trait_select_clause = (
    qualified_identifier
  * Token.t (* "::" *)
  * identifier (*tok*)
  * Token.t (* "insteadof" *)
  * qualified_identifier
  * (Token.t (* "," *) * qualified_identifier) list (* zero or more *)
)

type namespace_identifier = [
    `Qual_id_opt_back of (qualified_identifier * Token.t (* "\\" *) option)
  | `Back of Token.t (* "\\" *)
]

type type_constant_ = (
    [ `Qual_id of qualified_identifier | `Type_cst_ of type_constant_ ]
  * Token.t (* "::" *)
  * identifier (*tok*)
)

type xhp_close = (Token.t (* "</" *) * xhp_identifier_ * Token.t (* ">" *))

type xhp_children_declaration = (
    Token.t (* "children" *)
  * xhp_attribute_expression
  * (Token.t (* "," *) * xhp_attribute_expression) list (* zero or more *)
  * Token.t (* ";" *)
)

type keyword = [
    `Type of Token.t (* "type" *)
  | `Newt of Token.t (* "newtype" *)
  | `Shape of Token.t (* "shape" *)
  | `Tupe of Token.t (* "tupe" *)
  | `Clone of Token.t (* "clone" *)
  | `New of Token.t (* "new" *)
  | `Print of Token.t (* "print" *)
  | `Choice_bool of primitive_type
  | `Choice_array of collection_type
]

type anonymous_function_use_clause = (
    Token.t (* "use" *)
  * Token.t (* "(" *)
  * variable (*tok*)
  * (Token.t (* "," *) * variable (*tok*)) list (* zero or more *)
  * Token.t (* "," *) option
  * Token.t (* ")" *)
)

type scoped_identifier = (
    [
        `Qual_id of qualified_identifier
      | `Var of variable (*tok*)
      | `Scope_id of scope_identifier
      | `Choice_xhp_id of xhp_identifier_
      | `Pipe_var of Token.t (* "$$" *)
    ]
  * Token.t (* "::" *)
  * [ `Id of identifier (*tok*) | `Var of variable (*tok*) ]
)

type use_clause = (
    use_type option
  * namespace_identifier
  * (Token.t (* "as" *) * identifier (*tok*)) option
)

type anon_choice_semg_exte_id_8bbc8de = [
    `Semg_exte_id of semgrep_extended_identifier
  | `Choice_type of keyword
]

type anon_choice_comp_stmt_c6c6bb4 = [
    `Comp_stmt of compound_statement
  | `SEMI of Token.t (* ";" *)
]

and anon_choice_exp_1701d0a = [
    `Exp of expression
  | `Elem_init of (expression * Token.t (* "=>" *) * expression)
]

and anon_choice_exp_rep_COMMA_choice_exp_opt_COMMA_e4364bb = (
    anon_choice_exp_1701d0a
  * (Token.t (* "," *) * anon_choice_exp_1701d0a) list (* zero or more *)
  * Token.t (* "," *) option
)

and anon_choice_field_spec_0e0e023 = [
    `Field_spec of (
        Token.t (* "?" *) option
      * expression
      * Token.t (* "=>" *)
      * type_
    )
  | `DOTDOTDOT of Token.t (* "..." *)
]

and anon_exp_rep_COMMA_exp_0bb260c = (
    expression
  * (Token.t (* "," *) * expression) list (* zero or more *)
)

and anonymous_function_expression = (
    Token.t (* "async" *) option
  * Token.t (* "function" *)
  * parameters
  * (Token.t (* ":" *) * type_) option
  * anonymous_function_use_clause option
  * compound_statement
)

and argument = [
    `Opt_choice_inout_modi_exp of (
        [
            `Inout_modi of Token.t (* "inout" *)
          | `Vari_modi of Token.t (* "..." *)
        ]
          option
      * expression
    )
  | `Semg_vari_id of semgrep_variadic_identifier (*tok*)
]

and arguments = (
    Token.t (* "(" *)
  * (
        argument
      * (Token.t (* "," *) * argument) list (* zero or more *)
      * Token.t (* "," *) option
    )
      option
  * Token.t (* ")" *)
)

and array_ = (
    collection_type
  * type_arguments option
  * Token.t (* "[" *)
  * anon_choice_exp_rep_COMMA_choice_exp_opt_COMMA_e4364bb option
  * Token.t (* "]" *)
)

and as_expression = (
    expression
  * [
        `Tok_pdyn_n1_as of tok_pdyn_n1_as (*tok*)
      | `QMARKas of Token.t (* "?as" *)
    ]
  * type_
)

and attribute_modifier = (
    Token.t (* "<<" *)
  * qualified_identifier
  * arguments option
  * (Token.t (* "," *) * qualified_identifier * arguments option)
      list (* zero or more *)
  * Token.t (* "," *) option
  * Token.t (* ">>" *)
)

and awaitable_expression = (Token.t (* "async" *) * compound_statement)

and binary_expression = [
    `Exp_BARGT_exp of (expression * Token.t (* "|>" *) * expression)
  | `Exp_QMARKQMARK_exp of (expression * Token.t (* "??" *) * expression)
  | `Exp_BARBAR_exp of (expression * Token.t (* "||" *) * expression)
  | `Exp_AMPAMP_exp of (expression * Token.t (* "&&" *) * expression)
  | `Exp_BAR_exp of (expression * Token.t (* "|" *) * expression)
  | `Exp_HAT_exp of (expression * Token.t (* "^" *) * expression)
  | `Exp_AMP_exp of (expression * Token.t (* "&" *) * expression)
  | `Exp_EQEQ_exp of (expression * Token.t (* "==" *) * expression)
  | `Exp_BANGEQ_exp of (expression * Token.t (* "!=" *) * expression)
  | `Exp_EQEQEQ_exp of (expression * Token.t (* "===" *) * expression)
  | `Exp_BANGEQEQ_exp of (expression * Token.t (* "!==" *) * expression)
  | `Exp_LT_exp of (expression * Token.t (* "<" *) * expression)
  | `Exp_GT_exp of (expression * Token.t (* ">" *) * expression)
  | `Exp_LTEQ_exp of (expression * Token.t (* "<=" *) * expression)
  | `Exp_GTEQ_exp of (expression * Token.t (* ">=" *) * expression)
  | `Exp_LTEQGT_exp of (expression * Token.t (* "<=>" *) * expression)
  | `Exp_LTLT_exp of (expression * Token.t (* "<<" *) * expression)
  | `Exp_GTGT_exp of (expression * Token.t (* ">>" *) * expression)
  | `Exp_PLUS_exp of (expression * Token.t (* "+" *) * expression)
  | `Exp_DASH_exp of (expression * Token.t (* "-" *) * expression)
  | `Exp_DOT_exp of (expression * Token.t (* "." *) * expression)
  | `Exp_STAR_exp of (expression * Token.t (* "*" *) * expression)
  | `Exp_SLASH_exp of (expression * Token.t (* "/" *) * expression)
  | `Exp_PERC_exp of (expression * Token.t (* "%" *) * expression)
  | `Exp_STARSTAR_exp of (expression * Token.t (* "**" *) * expression)
  | `Exp_QMARKCOLON_exp of (expression * Token.t (* "?:" *) * expression)
  | `Exp_EQ_exp of (expression * Token.t (* "=" *) * expression)
  | `Exp_QMARKQMARKEQ_exp of (expression * Token.t (* "??=" *) * expression)
  | `Exp_DOTEQ_exp of (expression * Token.t (* ".=" *) * expression)
  | `Exp_BAREQ_exp of (expression * Token.t (* "|=" *) * expression)
  | `Exp_HATEQ_exp of (expression * Token.t (* "^=" *) * expression)
  | `Exp_AMPEQ_exp of (expression * Token.t (* "&=" *) * expression)
  | `Exp_LTLTEQ_exp of (expression * Token.t (* "<<=" *) * expression)
  | `Exp_GTGTEQ_exp of (expression * Token.t (* ">>=" *) * expression)
  | `Exp_PLUSEQ_exp of (expression * Token.t (* "+=" *) * expression)
  | `Exp_DASHEQ_exp of (expression * Token.t (* "-=" *) * expression)
  | `Exp_STAREQ_exp of (expression * Token.t (* "*=" *) * expression)
  | `Exp_SLASHEQ_exp of (expression * Token.t (* "/=" *) * expression)
  | `Exp_PERCEQ_exp of (expression * Token.t (* "%=" *) * expression)
  | `Exp_STARSTAREQ_exp of (expression * Token.t (* "**=" *) * expression)
]

and braced_expression = (Token.t (* "{" *) * expression * Token.t (* "}" *))

and call_expression = (
    [ `Exp of expression | `Choice_array of collection_type ]
  * type_arguments option
  * arguments
)

and cast_expression = (
    Token.t (* "(" *)
  * [
        `Array of Token.t (* "array" *)
      | `Int of Token.t (* "int" *)
      | `Float of Token.t (* "float" *)
      | `Str of Token.t (* "string" *)
      | `Bool of Token.t (* "bool" *)
    ]
  * Token.t (* ")" *)
  * expression
)

and catch_clause = (
    Token.t (* "catch" *) * Token.t (* "(" *) * type_ * variable (*tok*)
  * Token.t (* ")" *) * compound_statement
)

and class_const_declaration = (
    member_modifier list (* zero or more *)
  * Token.t (* "const" *)
  * type_ option
  * class_const_declarator
  * (Token.t (* "," *) * class_const_declarator) list (* zero or more *)
  * Token.t (* ";" *)
)

and class_const_declarator = (
    anon_choice_semg_exte_id_8bbc8de
  * (Token.t (* "=" *) * expression) option
)

and collection = (
    qualified_identifier
  * Token.t (* "{" *)
  * anon_choice_exp_rep_COMMA_choice_exp_opt_COMMA_e4364bb option
  * Token.t (* "}" *)
)

and compound_statement = (
    Token.t (* "{" *)
  * statement list (* zero or more *)
  * Token.t (* "}" *)
)

and const_declarator = (
    anon_choice_semg_exte_id_8bbc8de * Token.t (* "=" *) * expression
)

and declaration = [
    `Func_decl of (
        attribute_modifier option
      * function_declaration_header
      * anon_choice_comp_stmt_c6c6bb4
    )
  | `Class_decl of (
        attribute_modifier option
      * class_modifier option
      * class_modifier option
      * Token.t (* "xhp" *) option
      * Token.t (* "class" *)
      * [
            `Semg_exte_id of semgrep_extended_identifier
          | `Choice_xhp_id of xhp_identifier_
        ]
      * type_parameters option
      * extends_clause option
      * implements_clause option
      * where_clause option
      * member_declarations
    )
  | `Inte_decl of (
        attribute_modifier option
      * Token.t (* "interface" *)
      * semgrep_extended_identifier
      * type_parameters option
      * extends_clause option
      * where_clause option
      * member_declarations
    )
  | `Trait_decl of (
        attribute_modifier option
      * Token.t (* "trait" *)
      * semgrep_extended_identifier
      * type_parameters option
      * implements_clause option
      * where_clause option
      * member_declarations
    )
  | `Alias_decl of (
        attribute_modifier option
      * [ `Type of Token.t (* "type" *) | `Newt of Token.t (* "newtype" *) ]
      * semgrep_extended_identifier
      * type_parameters option
      * (Token.t (* "as" *) * type_) option
      * Token.t (* "=" *)
      * type_
      * Token.t (* ";" *)
    )
  | `Enum_decl of (
        attribute_modifier option
      * Token.t (* "enum" *)
      * semgrep_extended_identifier
      * Token.t (* ":" *)
      * type_
      * (Token.t (* "as" *) * type_) option
      * Token.t (* "{" *)
      * enumerator list (* zero or more *)
      * Token.t (* "}" *)
    )
  | `Name_decl of (
        Token.t (* "namespace" *)
      * [
            `Qual_id_SEMI of (qualified_identifier * Token.t (* ";" *))
          | `Opt_qual_id_comp_stmt of (
                qualified_identifier option
              * compound_statement
            )
        ]
          option
    )
  | `Const_decl of (
        Token.t (* "const" *)
      * type_ option
      * const_declarator
      * (Token.t (* "," *) * const_declarator) list (* zero or more *)
      * Token.t (* ";" *)
    )
]

and embedded_brace_expression = (
    embedded_brace_expression_ * Token.t (* "}" *)
)

and embedded_brace_expression_ = [
    `Tok_lcur_pat_0e8e4b6 of tok_lcurldollar_pat_0e8e4b6
  | `Embe_brace_call_exp of (embedded_brace_expression_ * arguments)
  | `Embe_brace_subs_exp of (
        embedded_brace_expression_
      * Token.t (* "[" *)
      * expression option
      * Token.t (* "]" *)
    )
  | `Embe_brace_sele_exp of (
        embedded_brace_expression_ * anon_choice_QMARKDASHGT_ce9cc19
      * variablish
    )
]

and enumerator = (
    semgrep_extended_identifier * Token.t (* "=" *) * expression
  * Token.t (* ";" *)
)

and expression = [
    `Choice_here of [
        `Here of heredoc
      | `Array of array_
      | `Tuple of tuple
      | `Shape of shape
      | `Coll of collection
      | `Choice_str of literal
      | `Choice_var of variablish
      | `Pref_str of prefixed_string
      | `Paren_exp of parenthesized_expression
      | `Bin_exp of binary_expression
      | `Prefix_un_exp of prefix_unary_expression
      | `Post_un_exp of postfix_unary_expression
      | `Is_exp of is_expression
      | `As_exp of as_expression
      | `Awai_exp of awaitable_expression
      | `Yield_exp of yield_expression
      | `Cast_exp of cast_expression
      | `Tern_exp of ternary_expression
      | `Lambda_exp of lambda_expression
      | `Call_exp of call_expression
      | `Sele_exp of selection_expression
      | `New_exp of new_expression
      | `Incl_exp of include_expression
      | `Requ_exp of require_expression
      | `Anon_func_exp of anonymous_function_expression
      | `Xhp_exp of xhp_expression
    ]
  | `Ellips of Token.t (* "..." *)
  | `Deep_ellips of (
        Token.t (* "<..." *) * expression * Token.t (* "...>" *)
    )
]

and expression_statement = (expression * Token.t (* ";" *))

and extends_clause = (
    Token.t (* "extends" *)
  * type_
  * (Token.t (* "," *) * type_) list (* zero or more *)
)

and field_initializer = (
    [ `Str of string_ (*tok*) | `Scoped_id of scoped_identifier ]
  * Token.t (* "=>" *)
  * expression
)

and finally_clause = (Token.t (* "finally" *) * compound_statement)

and function_declaration_header = (
    Token.t (* "async" *) option
  * Token.t (* "function" *)
  * semgrep_extended_identifier
  * type_parameters option
  * parameters
  * (Token.t (* ":" *) * attribute_modifier option * type_) option
  * where_clause option
)

and heredoc = (
    Token.t (* "<<<" *)
  * heredoc_start (*tok*)
  * heredoc_start_newline (*tok*) option
  * [
        `Here_body of heredoc_body (*tok*)
      | `Var of variable (*tok*)
      | `Embe_brace_exp of embedded_brace_expression
    ]
      list (* zero or more *)
  * heredoc_end_newline (*tok*) option
  * heredoc_end (*tok*)
)

and implements_clause = (
    Token.t (* "implements" *)
  * type_
  * (Token.t (* "," *) * type_) list (* zero or more *)
)

and include_expression = (
    [
        `Incl of Token.t (* "include" *)
      | `Incl_once of Token.t (* "include_once" *)
    ]
  * expression
)

and is_expression = (expression * Token.t (* "is" *) * type_)

and lambda_expression = (
    attribute_modifier option
  * Token.t (* "async" *) option
  * [
        `Single_param_params of variable (*tok*)
      | `Params_opt_COLON_choice_type_spec of (
            parameters
          * (Token.t (* ":" *) * type_) option
        )
    ]
  * Token.t (* "==>" *)
  * [ `Exp of expression | `Comp_stmt of compound_statement ]
)

and member_declarations = (
    Token.t (* "{" *)
  * [
        `Class_const_decl of class_const_declaration
      | `Meth_decl of method_declaration
      | `Prop_decl of property_declaration
      | `Type_const_decl of type_const_declaration
      | `Trait_use_clause of trait_use_clause
      | `Requ_imples_clause of require_implements_clause
      | `Requ_extends_clause of require_extends_clause
      | `Xhp_attr_decl of xhp_attribute_declaration
      | `Xhp_chil_decl of xhp_children_declaration
      | `Xhp_cate_decl of xhp_category_declaration
      | `Ellips of Token.t (* "..." *)
    ]
      list (* zero or more *)
  * Token.t (* "}" *)
)

and method_declaration = (
    attribute_modifier option
  * member_modifier list (* zero or more *)
  * function_declaration_header
  * anon_choice_comp_stmt_c6c6bb4
)

and new_expression = (
    Token.t (* "new" *)
  * variablish
  * type_arguments option
  * arguments
)

and parameter = [
    `Opt_attr_modi_opt_visi_modi_opt_inout_modi_opt_choice_type_spec_opt_vari_modi_var_opt_EQ_exp of (
        attribute_modifier option
      * visibility_modifier option
      * Token.t (* "inout" *) option
      * type_ option
      * Token.t (* "..." *) option
      * variable (*tok*)
      * (Token.t (* "=" *) * expression) option
    )
  | `Ellips of Token.t (* "..." *)
]

and parameters = (
    Token.t (* "(" *)
  * [
        `Vari_modi of Token.t (* "..." *)
      | `Param_rep_COMMA_param_opt_COMMA of (
            parameter
          * (Token.t (* "," *) * parameter) list (* zero or more *)
          * Token.t (* "," *) option
        )
    ]
      option
  * Token.t (* ")" *)
)

and parenthesized_expression = (
    Token.t (* "(" *) * expression * Token.t (* ")" *)
)

and postfix_unary_expression = (
    expression
  * [ `PLUSPLUS of Token.t (* "++" *) | `DASHDASH of Token.t (* "--" *) ]
)

and prefix_unary_expression = [
    `BANG_exp of (Token.t (* "!" *) * expression)
  | `TILDE_exp of (Token.t (* "~" *) * expression)
  | `DASH_exp of (Token.t (* "-" *) * expression)
  | `PLUS_exp of (Token.t (* "+" *) * expression)
  | `PLUSPLUS_exp of (Token.t (* "++" *) * expression)
  | `DASHDASH_exp of (Token.t (* "--" *) * expression)
  | `Print_exp of (Token.t (* "print" *) * expression)
  | `Clone_exp of (Token.t (* "clone" *) * expression)
  | `Await_exp of (Token.t (* "await" *) * expression)
  | `AT_exp of (Token.t (* "@" *) * expression)
]

and property_declaration = (
    attribute_modifier option
  * member_modifier list (* zero or more *)
  * type_ option
  * property_declarator
  * (Token.t (* "," *) * property_declarator) list (* zero or more *)
  * Token.t (* ";" *)
)

and property_declarator = (
    variable (*tok*)
  * (Token.t (* "=" *) * expression) option
)

and require_expression = (
    [
        `Requ of Token.t (* "require" *)
      | `Requ_once of Token.t (* "require_once" *)
    ]
  * expression
)

and require_extends_clause = (
    Token.t (* "require" *)
  * Token.t (* "extends" *)
  * type_
  * (Token.t (* "," *) * type_) list (* zero or more *)
  * Token.t (* ";" *)
)

and require_implements_clause = (
    Token.t (* "require" *)
  * Token.t (* "implements" *)
  * type_
  * (Token.t (* "," *) * type_) list (* zero or more *)
  * Token.t (* ";" *)
)

and selection_expression = (
    [ `Choice_var of variablish | `As_exp of as_expression ]
  * anon_choice_QMARKDASHGT_ce9cc19
  * [
        `Choice_var of variablish
      | `Braced_exp of braced_expression
      | `Choice_type of keyword
    ]
)

and shape = (
    Token.t (* "shape" *)
  * Token.t (* "(" *)
  * (
        field_initializer
      * (Token.t (* "," *) * field_initializer) list (* zero or more *)
      * Token.t (* "," *) option
    )
      option
  * Token.t (* ")" *)
)

and statement = [
    `Choice_func_decl of declaration
  | `Comp_stmt of compound_statement
  | `Empty_stmt of empty_statement
  | `Exp_stmt of expression_statement
  | `Ret_stmt of (
        Token.t (* "return" *)
      * expression option
      * Token.t (* ";" *)
    )
  | `Brk_stmt of (
        Token.t (* "break" *)
      * expression option
      * Token.t (* ";" *)
    )
  | `Cont_stmt of (
        Token.t (* "continue" *)
      * expression option
      * Token.t (* ";" *)
    )
  | `Throw_stmt of (Token.t (* "throw" *) * expression * Token.t (* ";" *))
  | `Echo_stmt of (
        Token.t (* "echo" *)
      * expression
      * (Token.t (* "," *) * expression) list (* zero or more *)
      * Token.t (* ";" *)
    )
  | `Unset_stmt of (
        Token.t (* "unset" *)
      * Token.t (* "(" *)
      * (
            variablish
          * (Token.t (* "," *) * variablish) list (* zero or more *)
        )
          option
      * Token.t (* ")" *)
      * Token.t (* ";" *)
    )
  | `Use_stmt of (
        Token.t (* "use" *)
      * [
            `Use_clause_rep_COMMA_use_clause_opt_COMMA of (
                use_clause
              * (Token.t (* "," *) * use_clause) list (* zero or more *)
              * Token.t (* "," *) option
            )
          | `Opt_use_type_name_id_LCURL_use_clause_rep_COMMA_use_clause_opt_COMMA_RCURL of (
                use_type option
              * namespace_identifier
              * Token.t (* "{" *)
              * use_clause
              * (Token.t (* "," *) * use_clause) list (* zero or more *)
              * Token.t (* "," *) option
              * Token.t (* "}" *)
            )
        ]
      * Token.t (* ";" *)
    )
  | `If_stmt of (
        Token.t (* "if" *)
      * parenthesized_expression
      * statement
      * (
            [
                `Elseif of Token.t (* "elseif" *)
              | `Else_if of (Token.t (* "else" *) * Token.t (* "if" *))
            ]
          * parenthesized_expression
          * statement
        )
          list (* zero or more *)
      * (Token.t (* "else" *) * statement) option
    )
  | `While_stmt of (
        Token.t (* "while" *) * parenthesized_expression * statement
    )
  | `Do_stmt of (
        Token.t (* "do" *) * statement * Token.t (* "while" *)
      * parenthesized_expression * Token.t (* ";" *)
    )
  | `For_stmt of (
        Token.t (* "for" *)
      * Token.t (* "(" *)
      * anon_exp_rep_COMMA_exp_0bb260c option
      * Token.t (* ";" *)
      * anon_exp_rep_COMMA_exp_0bb260c option
      * Token.t (* ";" *)
      * anon_exp_rep_COMMA_exp_0bb260c option
      * Token.t (* ")" *)
      * statement
    )
  | `Switch_stmt of (
        Token.t (* "switch" *)
      * parenthesized_expression
      * Token.t (* "{" *)
      * [ `Switch_case of switch_case | `Switch_defa of switch_default ]
          list (* zero or more *)
      * Token.t (* "}" *)
    )
  | `Fore_stmt of (
        Token.t (* "foreach" *)
      * Token.t (* "(" *)
      * expression
      * Token.t (* "await" *) option
      * tok_pdyn_p1_as (*tok*)
      * (variablish * Token.t (* "=>" *)) option
      * variablish
      * Token.t (* ")" *)
      * statement
    )
  | `Try_stmt of (
        Token.t (* "try" *)
      * compound_statement
      * catch_clause list (* zero or more *)
      * [ `Catch_clause of catch_clause | `Fina_clause of finally_clause ]
    )
  | `Conc_stmt of (Token.t (* "concurrent" *) * compound_statement)
  | `Using_stmt of (
        Token.t (* "await" *) option
      * Token.t (* "using" *)
      * [
            `Exp_stmt of expression_statement
          | `LPAR_exp_rep_COMMA_exp_RPAR_choice_comp_stmt of (
                Token.t (* "(" *)
              * expression
              * (Token.t (* "," *) * expression) list (* zero or more *)
              * Token.t (* ")" *)
              * anon_choice_comp_stmt_c6c6bb4
            )
        ]
    )
]

and switch_case = (
    Token.t (* "case" *)
  * expression
  * Token.t (* ":" *)
  * statement list (* zero or more *)
)

and switch_default = (
    Token.t (* "default" *)
  * Token.t (* ":" *)
  * statement list (* zero or more *)
)

and ternary_expression = (
    expression * Token.t (* "?" *) * expression * Token.t (* ":" *)
  * expression
)

and trait_use_clause = (
    Token.t (* "use" *)
  * type_
  * (Token.t (* "," *) * type_) list (* zero or more *)
  * [
        `LCURL_rep_choice_trait_select_clause_SEMI_RCURL of (
            Token.t (* "{" *)
          * (
                [
                    `Trait_select_clause of trait_select_clause
                  | `Trait_alias_clause of trait_alias_clause
                ]
              * Token.t (* ";" *)
            )
              list (* zero or more *)
          * Token.t (* "}" *)
        )
      | `SEMI of Token.t (* ";" *)
    ]
)

and tuple = (
    Token.t (* "tuple" *)
  * Token.t (* "(" *)
  * (
        expression
      * (Token.t (* "," *) * expression) list (* zero or more *)
      * Token.t (* "," *) option
    )
      option
  * Token.t (* ")" *)
)

and type_ = [
    `Type_spec of (
        type_modifier list (* zero or more *)
      * [
            `Choice_bool of primitive_type
          | `Qual_id of qualified_identifier
          | `Choice_array of collection_type
          | `Choice_xhp_id of xhp_identifier_
        ]
      * type_arguments option
    )
  | `Type_cst of (type_modifier list (* zero or more *) * type_constant_)
  | `Shape_type_spec of (
        type_modifier list (* zero or more *)
      * Token.t (* "shape" *)
      * Token.t (* "(" *)
      * (
            anon_choice_field_spec_0e0e023
          * (Token.t (* "," *) * anon_choice_field_spec_0e0e023)
              list (* zero or more *)
          * Token.t (* "," *) option
        )
          option
      * Token.t (* ")" *)
    )
  | `Func_type_spec of (
        type_modifier list (* zero or more *)
      * Token.t (* "(" *)
      * pat_466b599
      * (
            Token.t (* "inout" *) option
          * type_
          * Token.t (* "..." *) option
          * (
                Token.t (* "," *)
              * Token.t (* "inout" *) option
              * type_
              * Token.t (* "..." *) option
            )
              list (* zero or more *)
          * Token.t (* "," *) option
        )
          option
      * Token.t (* ")" *)
      * Token.t (* ":" *)
      * type_
      * Token.t (* ")" *)
    )
  | `Tuple_type_spec of (
        type_modifier list (* zero or more *)
      * Token.t (* "(" *)
      * type_
      * (Token.t (* "," *) * type_) list (* zero or more *)
      * Token.t (* "," *) option
      * Token.t (* ")" *)
    )
]

and type_arguments = (
    Token.t (* "<" *)
  * (
        type_
      * (Token.t (* "," *) * type_) list (* zero or more *)
      * Token.t (* "," *) option
    )
      option
  * Token.t (* ">" *)
)

and type_const_declaration = (
    attribute_modifier option
  * member_modifier list (* zero or more *)
  * Token.t (* "const" *)
  * Token.t (* "type" *)
  * semgrep_extended_identifier
  * type_parameters option
  * (Token.t (* "as" *) * type_) option
  * (Token.t (* "=" *) * type_) option
  * Token.t (* ";" *)
)

and type_parameter = (
    attribute_modifier option
  * [
        `PLUS of Token.t (* "+" *)
      | `DASH of Token.t (* "-" *)
      | `Reify of Token.t (* "reify" *)
    ]
      option
  * identifier (*tok*)
  * ([ `As of Token.t (* "as" *) | `Super of Token.t (* "super" *) ] * type_)
      list (* zero or more *)
)

and type_parameters = (
    Token.t (* "<" *)
  * type_parameter
  * (Token.t (* "," *) * type_parameter) list (* zero or more *)
  * Token.t (* "," *) option
  * Token.t (* ">" *)
)

and variablish = [
    `Var of variable (*tok*)
  | `Pipe_var of Token.t (* "$$" *)
  | `List_exp of (
        Token.t (* "list" *)
      * Token.t (* "(" *)
      * expression option
      * (Token.t (* "," *) * expression option) list (* zero or more *)
      * Token.t (* "," *) option
      * Token.t (* ")" *)
    )
  | `Subs_exp of (
        expression
      * Token.t (* "[" *)
      * expression option
      * Token.t (* "]" *)
    )
  | `Qual_id of qualified_identifier
  | `Paren_exp of parenthesized_expression
  | `Call_exp of call_expression
  | `Scoped_id of scoped_identifier
  | `Scope_id of scope_identifier
  | `Sele_exp of selection_expression
  | `Choice_xhp_id of xhp_identifier_
]

and where_clause = (
    Token.t (* "where" *)
  * (where_constraint * Token.t (* "," *) option) list (* one or more *)
)

and where_constraint = (
    type_
  * [
        `As of Token.t (* "as" *)
      | `Super of Token.t (* "super" *)
      | `EQ of Token.t (* "=" *)
    ]
  * type_
)

and xhp_attribute = [
    `Xhp_id_EQ_choice_str of (
        xhp_identifier (*tok*)
      * Token.t (* "=" *)
      * [ `Str of string_ (*tok*) | `Braced_exp of braced_expression ]
    )
  | `Choice_braced_exp of [
        `Braced_exp of braced_expression
      | `Xhp_spread_exp of xhp_spread_expression
    ]
]

and xhp_attribute_declaration = (
    Token.t (* "attribute" *)
  * xhp_class_attribute
  * (Token.t (* "," *) * xhp_class_attribute) list (* zero or more *)
  * Token.t (* ";" *)
)

and xhp_class_attribute = (
    [ `Choice_type_spec of type_ | `Xhp_enum_type of xhp_enum_type ]
  * xhp_identifier (*tok*) option
  * (Token.t (* "=" *) * expression) option
  * [
        `ATre of Token.t (* "@required" *)
      | `ATla of Token.t (* "@lateinit" *)
    ]
      option
)

and xhp_expression = [
    `Xhp_open_close of (
        Token.t (* "<" *)
      * xhp_identifier_
      * xhp_attribute list (* zero or more *)
      * Token.t (* "/>" *)
    )
  | `Xhp_open_rep_choice_xhp_str_xhp_close of (
        xhp_open
      * [
            `Xhp_str of xhp_string (*tok*)
          | `Xhp_comm of xhp_comment (*tok*)
          | `Braced_exp of braced_expression
          | `Xhp_exp of xhp_expression
        ]
          list (* zero or more *)
      * xhp_close
    )
]

and xhp_open = (
    Token.t (* "<" *)
  * xhp_identifier_
  * xhp_attribute list (* zero or more *)
  * Token.t (* ">" *)
)

and xhp_spread_expression = (
    Token.t (* "{" *) * Token.t (* "..." *) * expression * Token.t (* "}" *)
)

and yield_expression = (Token.t (* "yield" *) * anon_choice_exp_1701d0a)

type script = (pat_b6fe07e option * statement list (* zero or more *))

type final_modifier (* inlined *) = Token.t (* "final" *)

type ellipsis (* inlined *) = Token.t (* "..." *)

type backslash (* inlined *) = Token.t (* "\\" *)

type inout_modifier (* inlined *) = Token.t (* "inout" *)

type comment (* inlined *) = Token.t

type pipe_variable (* inlined *) = Token.t (* "$$" *)

type variadic_modifier (* inlined *) = Token.t (* "..." *)

type async_modifier (* inlined *) = Token.t (* "async" *)

type xhp_modifier (* inlined *) = Token.t (* "xhp" *)

type static_modifier (* inlined *) = Token.t (* "static" *)

type abstract_modifier (* inlined *) = Token.t (* "abstract" *)

type await_modifier (* inlined *) = Token.t (* "await" *)

type single_parameter (* inlined *) = variable (*tok*)

type xhp_binary_expression (* inlined *) = (
    xhp_attribute_expression * Token.t (* "|" *) * xhp_attribute_expression
)

type xhp_parenthesized_expression (* inlined *) = (
    Token.t (* "(" *)
  * xhp_attribute_expression
  * (Token.t (* "," *) * xhp_attribute_expression) list (* zero or more *)
  * Token.t (* ")" *)
)

type xhp_postfix_unary_expression (* inlined *) = (
    xhp_attribute_expression
  * [
        `PLUS of Token.t (* "+" *)
      | `STAR of Token.t (* "*" *)
      | `QMARK of Token.t (* "?" *)
    ]
)

type single_parameter_parameters (* inlined *) = variable (*tok*)

type type_constant (* inlined *) = (
    type_modifier list (* zero or more *)
  * type_constant_
)

type use_statement (* inlined *) = (
    Token.t (* "use" *)
  * [
        `Use_clause_rep_COMMA_use_clause_opt_COMMA of (
            use_clause
          * (Token.t (* "," *) * use_clause) list (* zero or more *)
          * Token.t (* "," *) option
        )
      | `Opt_use_type_name_id_LCURL_use_clause_rep_COMMA_use_clause_opt_COMMA_RCURL of (
            use_type option
          * namespace_identifier
          * Token.t (* "{" *)
          * use_clause
          * (Token.t (* "," *) * use_clause) list (* zero or more *)
          * Token.t (* "," *) option
          * Token.t (* "}" *)
        )
    ]
  * Token.t (* ";" *)
)

type alias_declaration (* inlined *) = (
    attribute_modifier option
  * [ `Type of Token.t (* "type" *) | `Newt of Token.t (* "newtype" *) ]
  * semgrep_extended_identifier
  * type_parameters option
  * (Token.t (* "as" *) * type_) option
  * Token.t (* "=" *)
  * type_
  * Token.t (* ";" *)
)

type break_statement (* inlined *) = (
    Token.t (* "break" *)
  * expression option
  * Token.t (* ";" *)
)

type class_declaration (* inlined *) = (
    attribute_modifier option
  * class_modifier option
  * class_modifier option
  * Token.t (* "xhp" *) option
  * Token.t (* "class" *)
  * [
        `Semg_exte_id of semgrep_extended_identifier
      | `Choice_xhp_id of xhp_identifier_
    ]
  * type_parameters option
  * extends_clause option
  * implements_clause option
  * where_clause option
  * member_declarations
)

type concurrent_statement (* inlined *) = (
    Token.t (* "concurrent" *) * compound_statement
)

type const_declaration (* inlined *) = (
    Token.t (* "const" *)
  * type_ option
  * const_declarator
  * (Token.t (* "," *) * const_declarator) list (* zero or more *)
  * Token.t (* ";" *)
)

type continue_statement (* inlined *) = (
    Token.t (* "continue" *)
  * expression option
  * Token.t (* ";" *)
)

type deep_ellipsis (* inlined *) = (
    Token.t (* "<..." *) * expression * Token.t (* "...>" *)
)

type do_statement (* inlined *) = (
    Token.t (* "do" *) * statement * Token.t (* "while" *)
  * parenthesized_expression * Token.t (* ";" *)
)

type echo_statement (* inlined *) = (
    Token.t (* "echo" *)
  * expression
  * (Token.t (* "," *) * expression) list (* zero or more *)
  * Token.t (* ";" *)
)

type element_initializer (* inlined *) = (
    expression * Token.t (* "=>" *) * expression
)

type embedded_brace_call_expression (* inlined *) = (
    embedded_brace_expression_ * arguments
)

type embedded_brace_selection_expression (* inlined *) = (
    embedded_brace_expression_ * anon_choice_QMARKDASHGT_ce9cc19 * variablish
)

type embedded_brace_subscript_expression (* inlined *) = (
    embedded_brace_expression_
  * Token.t (* "[" *)
  * expression option
  * Token.t (* "]" *)
)

type enum_declaration (* inlined *) = (
    attribute_modifier option
  * Token.t (* "enum" *)
  * semgrep_extended_identifier
  * Token.t (* ":" *)
  * type_
  * (Token.t (* "as" *) * type_) option
  * Token.t (* "{" *)
  * enumerator list (* zero or more *)
  * Token.t (* "}" *)
)

type field_specifier (* inlined *) = (
    Token.t (* "?" *) option
  * expression
  * Token.t (* "=>" *)
  * type_
)

type for_statement (* inlined *) = (
    Token.t (* "for" *)
  * Token.t (* "(" *)
  * anon_exp_rep_COMMA_exp_0bb260c option
  * Token.t (* ";" *)
  * anon_exp_rep_COMMA_exp_0bb260c option
  * Token.t (* ";" *)
  * anon_exp_rep_COMMA_exp_0bb260c option
  * Token.t (* ")" *)
  * statement
)

type foreach_statement (* inlined *) = (
    Token.t (* "foreach" *)
  * Token.t (* "(" *)
  * expression
  * Token.t (* "await" *) option
  * tok_pdyn_p1_as (*tok*)
  * (variablish * Token.t (* "=>" *)) option
  * variablish
  * Token.t (* ")" *)
  * statement
)

type function_declaration (* inlined *) = (
    attribute_modifier option
  * function_declaration_header
  * anon_choice_comp_stmt_c6c6bb4
)

type function_type_specifier (* inlined *) = (
    type_modifier list (* zero or more *)
  * Token.t (* "(" *)
  * pat_466b599
  * (
        Token.t (* "inout" *) option
      * type_
      * Token.t (* "..." *) option
      * (
            Token.t (* "," *)
          * Token.t (* "inout" *) option
          * type_
          * Token.t (* "..." *) option
        )
          list (* zero or more *)
      * Token.t (* "," *) option
    )
      option
  * Token.t (* ")" *)
  * Token.t (* ":" *)
  * type_
  * Token.t (* ")" *)
)

type if_statement (* inlined *) = (
    Token.t (* "if" *)
  * parenthesized_expression
  * statement
  * (
        [
            `Elseif of Token.t (* "elseif" *)
          | `Else_if of (Token.t (* "else" *) * Token.t (* "if" *))
        ]
      * parenthesized_expression
      * statement
    )
      list (* zero or more *)
  * (Token.t (* "else" *) * statement) option
)

type interface_declaration (* inlined *) = (
    attribute_modifier option
  * Token.t (* "interface" *)
  * semgrep_extended_identifier
  * type_parameters option
  * extends_clause option
  * where_clause option
  * member_declarations
)

type list_expression (* inlined *) = (
    Token.t (* "list" *)
  * Token.t (* "(" *)
  * expression option
  * (Token.t (* "," *) * expression option) list (* zero or more *)
  * Token.t (* "," *) option
  * Token.t (* ")" *)
)

type namespace_declaration (* inlined *) = (
    Token.t (* "namespace" *)
  * [
        `Qual_id_SEMI of (qualified_identifier * Token.t (* ";" *))
      | `Opt_qual_id_comp_stmt of (
            qualified_identifier option
          * compound_statement
        )
    ]
      option
)

type return_statement (* inlined *) = (
    Token.t (* "return" *)
  * expression option
  * Token.t (* ";" *)
)

type shape_type_specifier (* inlined *) = (
    type_modifier list (* zero or more *)
  * Token.t (* "shape" *)
  * Token.t (* "(" *)
  * (
        anon_choice_field_spec_0e0e023
      * (Token.t (* "," *) * anon_choice_field_spec_0e0e023)
          list (* zero or more *)
      * Token.t (* "," *) option
    )
      option
  * Token.t (* ")" *)
)

type subscript_expression (* inlined *) = (
    expression
  * Token.t (* "[" *)
  * expression option
  * Token.t (* "]" *)
)

type switch_statement (* inlined *) = (
    Token.t (* "switch" *)
  * parenthesized_expression
  * Token.t (* "{" *)
  * [ `Switch_case of switch_case | `Switch_defa of switch_default ]
      list (* zero or more *)
  * Token.t (* "}" *)
)

type throw_statement (* inlined *) = (
    Token.t (* "throw" *) * expression * Token.t (* ";" *)
)

type trait_declaration (* inlined *) = (
    attribute_modifier option
  * Token.t (* "trait" *)
  * semgrep_extended_identifier
  * type_parameters option
  * implements_clause option
  * where_clause option
  * member_declarations
)

type try_statement (* inlined *) = (
    Token.t (* "try" *)
  * compound_statement
  * catch_clause list (* zero or more *)
  * [ `Catch_clause of catch_clause | `Fina_clause of finally_clause ]
)

type tuple_type_specifier (* inlined *) = (
    type_modifier list (* zero or more *)
  * Token.t (* "(" *)
  * type_
  * (Token.t (* "," *) * type_) list (* zero or more *)
  * Token.t (* "," *) option
  * Token.t (* ")" *)
)

type type_specifier (* inlined *) = (
    type_modifier list (* zero or more *)
  * [
        `Choice_bool of primitive_type
      | `Qual_id of qualified_identifier
      | `Choice_array of collection_type
      | `Choice_xhp_id of xhp_identifier_
    ]
  * type_arguments option
)

type unset_statement (* inlined *) = (
    Token.t (* "unset" *)
  * Token.t (* "(" *)
  * (variablish * (Token.t (* "," *) * variablish) list (* zero or more *))
      option
  * Token.t (* ")" *)
  * Token.t (* ";" *)
)

type using_statement (* inlined *) = (
    Token.t (* "await" *) option
  * Token.t (* "using" *)
  * [
        `Exp_stmt of expression_statement
      | `LPAR_exp_rep_COMMA_exp_RPAR_choice_comp_stmt of (
            Token.t (* "(" *)
          * expression
          * (Token.t (* "," *) * expression) list (* zero or more *)
          * Token.t (* ")" *)
          * anon_choice_comp_stmt_c6c6bb4
        )
    ]
)

type while_statement (* inlined *) = (
    Token.t (* "while" *) * parenthesized_expression * statement
)

type xhp_open_close (* inlined *) = (
    Token.t (* "<" *)
  * xhp_identifier_
  * xhp_attribute list (* zero or more *)
  * Token.t (* "/>" *)
)

type extra = Comment of Loc.t * comment

type extras = extra list
